<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
    <!-- responsive -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>WebRTC Web Client</title>
		<style>
			/* #localVideo {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 100px;
        height: 150px;
        object-fit: cover;
        border: 2px solid white;
            background: black;
        border-radius: 8px;
        z-index: 10;
        } */
		</style>
		<script src="https://cdn.tailwindcss.com/"></script>
	</head>
	<body class="bg-gray-900 min-h-screen flex flex-col max-h-screen">
	<!-- PH·∫¶N VIDEO -->
	<div class="flex-1 flex items-center justify-center overflow-y-auto">
		<div
			id="group-video"
			class="grid gap-4"
		>
			<video
				id="localVideo"
				class="bg-black w-full aspect-video rounded-xl shadow-lg ring-1 ring-white object-cover transition-all duration-300 ease-in-out"
				autoplay
				playsinline
				muted
			></video>
		</div>
	</div>

	<!-- PH·∫¶N N√öT ƒêI·ªÄU KHI·ªÇN -->
	<div class="bg-gray-800 p-4">
		<div class="flex flex-row items-center justify-center space-x-4">
			<button
				onclick="toggleCamera(this)"
				class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded transition"
			>
				T·∫Øt cam
			</button>
			<button
				onclick="toggleMute(this)"
				class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded transition"
			>
				T·∫Øt ti·∫øng
			</button>
			<button
				onclick="startScreenShare(this)"
				class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded transition"
			>
			  Chia s·∫ª m√†n h√¨nh
			</button>
			<button
				onclick="hangUp(this)"
				class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded transition"
			>
				R·ªùi ph√≤ng
			</button>
		</div>
	</div>

		<script src="/socket.io/socket.io.js"></script>
		<script>
      const groupVideo = document.getElementById("group-video");
			const socket = io("/webrtc");
      const urlParts = window.location.pathname.split("/");
      const conversationId = urlParts[3];
      const userId = urlParts[4];
      const messageId = urlParts[5];
      const ROOM_ID = `${conversationId}_room_${messageId}`;
      let screenStream = null;
      let screenVideo = null;

      let myId = null;
      const peers = {}; // socketId -> RTCPeerConnection
      let localStream = null;

      const localVideo = document.getElementById("localVideo");

      const iceServers = [
        {
            "url": "stun:global.stun.twilio.com:3478",
            "urls": "stun:global.stun.twilio.com:3478"
        },

    ]

    const startScreenShare = async (btn) => {
      try {
        screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
          audio: false, // N·∫øu mu·ªën share √¢m thanh th√¨ true
        });

        // T·∫°o th·∫ª video
        screenVideo = document.createElement("video");
        screenVideo.srcObject = screenStream;
        screenVideo.autoplay = true;
        screenVideo.playsInline = true;
        screenVideo.className =
          "bg-black w-full aspect-video rounded-xl shadow-lg ring-2 ring-yellow-500 object-cover transition-all duration-300 scale-95 opacity-0";

        // Th√™m v√†o DOM
        const groupVideo = document.getElementById("group-video");
        groupVideo.appendChild(screenVideo);

        // Animate cho ng·ªçt
        requestAnimationFrame(() => {
          screenVideo.classList.remove("scale-95", "opacity-0");
        });

        // C·∫≠p nh·∫≠t l·∫°i layout
        updateGridVideo();

        // X·ª≠ l√Ω khi ng∆∞·ªùi d√πng d·ª´ng chia s·∫ª
        screenStream.getVideoTracks()[0].onended = () => {
          stopScreenShare();
        };
      } catch (err) {
        console.error("‚ùå Kh√¥ng th·ªÉ chia s·∫ª m√†n h√¨nh:", err);
      }
    };

    const stopScreenShare = () => {
      if (screenStream) {
        screenStream.getTracks().forEach((track) => track.stop());
        screenStream = null;
      }
      if (screenVideo) {
        screenVideo.remove();
        screenVideo = null;
      }
      updateGridVideo();
    };

      // üîπ T·∫°o k·∫øt n·ªëi peer
      function createPeerConnection(socketId) {
        const pc = new RTCPeerConnection({ iceServers });

        // üî∏ Add local media
        localStream.getTracks().forEach((track) => {
          pc.addTrack(track, localStream);
        });

        // üî∏ Khi nh·∫≠n media t·ª´ ng∆∞·ªùi kh√°c
        pc.ontrack = (event) => {
          let remoteVideo = document.getElementById(`video-${socketId}`);
          if (!remoteVideo) {
            remoteVideo = document.createElement("video");
            remoteVideo.id = `video-${socketId}`;
            remoteVideo.autoplay = true;
            remoteVideo.playsInline = true;
            remoteVideo.className = "bg-black w-full aspect-video rounded-xl shadow-lg ring-2 ring-white object-cover transition-all duration-300 scale-95 opacity-0";
            groupVideo.appendChild(remoteVideo);
            requestAnimationFrame(() => {
              remoteVideo.classList.remove("scale-95", "opacity-0");
            });
          }
          if (event.streams && event.streams[0]) {
            remoteVideo.srcObject = event.streams[0];
          }
        };

        // üî∏ Khi c√≥ ICE Candidate
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit("signal", {
              to: socketId,
              type: "candidate",
              data: event.candidate,
            });
          }
        };

        return pc;
      }

      // Update grid video
      const updateGridVideo = () => {
        const videos = groupVideo.querySelectorAll("video");
        const numVideos = videos.length;

        if (numVideos > 0) {
          groupVideo.style.gridTemplateColumns = `repeat(${Math.min(numVideos, 6)}, 1fr)`;
          groupVideo.style.gridTemplateRows = `repeat(${Math.ceil(numVideos / 6)}, 1fr)`;
        }
      };

      // üîπ B·∫Øt ƒë·∫ßu camera & mic
      async function startLocalStream() {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
      }

      // üîπ X·ª≠ l√Ω t√≠n hi·ªáu t·ª´ peer kh√°c
      async function handleSignal(from, type, data) {
        let pc = peers[from];
        if (!pc) {
          pc = createPeerConnection(from);
          peers[from] = pc;
        }

        if (type === "offer") {
          await pc.setRemoteDescription(new RTCSessionDescription(data));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("signal", {
            to: from,
            type: "answer",
            data: answer,
          });
        } else if (type === "answer") {
          await pc.setRemoteDescription(new RTCSessionDescription(data));
        } else if (type === "candidate") {
          if (data) await pc.addIceCandidate(new RTCIceCandidate(data));
        }
      }

      // üîπ Khi socket k·∫øt n·ªëi
      socket.on("connect", async () => {
        myId = socket.id;
        await startLocalStream();
        socket.emit("join-room", {
          roomId: ROOM_ID,
          userId,
          conversationId,
          callId: messageId,
        });
      });

      // üîπ Nh·∫≠n danh s√°ch ng∆∞·ªùi trong ph√≤ng ‚Üí g·ªçi offer
      socket.on("room-users", async (users) => {
        updateGridVideo();
        users.forEach(async (otherSocketId) => {
          if (otherSocketId === myId) return;

          console.log("üìû Calling to:", otherSocketId);

          const pc = createPeerConnection(otherSocketId);
          peers[otherSocketId] = pc;

          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          socket.emit("signal", {
            to: otherSocketId,
            type: "offer",
            data: offer,
          });
        });
      });

      // üîπ Khi c√≥ ng∆∞·ªùi m·ªõi v√†o
      socket.on("user-joined", (socketId) => {
        console.log("üë§ New peer joined:", socketId);
        const pc = createPeerConnection(socketId);
        peers[socketId] = pc;
        updateGridVideo();
      });

      // üîπ Nh·∫≠n t√≠n hi·ªáu t·ª´ peer
      socket.on("signal", async ({ from, type, data }) => {
        console.log("üì° Signal:", from, type);
        await handleSignal(from, type, data);
        updateGridVideo();
      });

      // üîπ Khi ai ƒë√≥ r·ªùi
      socket.on("user-left", (data) => {
        const { socketId, reason } = data;
        
        console.warn("‚ùå User left:", socketId, "\nReason:", reason);

        // Xo√° video
        const video = document.getElementById(`video-${socketId}`);
        if (video) video.remove();

        // D·ªçn peer
        if (peers[socketId]) {
          peers[socketId].close();
          delete peers[socketId];
        }
        updateGridVideo();
      });

      // üîπ R·ªùi ph√≤ng
      function hangUp() {
        console.log("üëã Leaving room");
        socket.emit("leave-room", {
          roomId: ROOM_ID,
          userId,
          conversationId,
          callId: messageId,
        });

        Object.keys(peers).forEach((id) => {
          peers[id].close();
          delete peers[id];
        });

        localStream?.getTracks().forEach((track) => track.stop());
        localVideo.srcObject = null;
        socket.disconnect();

        window.location.href = "http://localhost:8081/";
      }

      // üîπ B·∫≠t/t·∫Øt cam
      function toggleCamera(button) {
        const videoTrack = localStream.getVideoTracks()[0];
        videoTrack.enabled = !videoTrack.enabled;
        button.textContent = videoTrack.enabled ? "T·∫Øt cam" : "B·∫≠t cam";
      }

      // üîπ B·∫≠t/t·∫Øt mic
      function toggleMute(button) {
        const audioTrack = localStream.getAudioTracks()[0];
        audioTrack.enabled = !audioTrack.enabled;
        button.textContent = audioTrack.enabled ? "T·∫Øt ti·∫øng" : "B·∫≠t ti·∫øng";
      }

		</script>
	</body>
</html>
